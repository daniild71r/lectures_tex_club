\section{Аллокация памяти}

\subsection{Физическая память}

Основные параметры:
\begin{itemize}
	\item частота шины (например, 1500 МГц).
	\item передача за одну секунду (например: 3000 MT/s).
\end{itemize}

\begin{Def}
	\underline{Латентность} --- задержка между командой и передачей данных.
\end{Def}

\subsection{Физическое адресное пространство}

Диапазон --- $2^{bits\_count}$

\subsection{Адресное пространство процесса}

У каждого процесса есть свое адресное пространство. Оно никак не пересекается
с адресным пространством других процессов.

Ограничения: 
\begin{itemize}
	\item 32-битные системы --- 4 Гб.
	\item 64-битные --- 256 Тб.
\end{itemize}

Пример содержимого:
\begin{itemize}
	\item Пространство ядра --- 0xc0000000
	\item Стек --- 0xbf800000
	\item Разделяемые библиотеки
	\item Куча
	\item Программа --- 0x004d9000
\end{itemize}

Для того, чтобы реализовать менеджмент памяти используется \textbf{страничная адресация}.

\subsection{Страничная адресация}

\begin{itemize}
	\item Разбиение памяти на \textbf{страницы} фиксированного размера.
	\item У каждой страницы есть свои атрибуты.
\end{itemize}

\subsection{Страничная адресация в x86-32}

32-битный адрес в виртуальном адресном пространстве разбивается на 3 части --- 
индекс в таблице первого уровня (10 бит), индекс в таблице второго уровня (10 бит) и 
смещение внутри страницы (12 бит).

\begin{itemize}
	\item Специальный регистр CR2 указывает на таблицу первого уровня текущего процесса.
	\item Каждая запись в таблицу первого уровня указывает на таблицу второго уровня.
	\item Записи в таблице второго уровня содержат указатели на страницы.
\end{itemize}

\begin{itemize}
	\item Размер страницы --- 4 Кб
	\item В каждой таблице есть до 1024 записей
\end{itemize}

Советую посмотреть \href{https://youtu.be/uSkrfUIYhqw?t=1355}{участок}
30 сек для лучшего понимания.

При кодировании у нас остается 12 бит для флагов --- это настройки страницы.

\subsection{Нарушение доступа к странице}

Флаг P (present --- файл существует в физицеской памяти) равен 0. Тогда процессор бросает исключение. Ядро обрабатывает это исключение.

\subsection{Аппаратная поддержка}

\begin{itemize}
	\item MMU (Memory Managment Unit) считает реальный указатель на используя указатель
	в виртуальном адресном пространстве.
	\item TLB (Translation Lookaside Buffer) предназначен для хранения текущих 
	таблиц в памяти.
	\item Размер страниц прописан на уровне процессора, вы не можете его поменять программно.
\end{itemize}

\subsection{Аллокаторы}

\begin{itemize}
	\item C++: стандартные new и new[] используют malloc/calloc. Это можно настраивать.
	\item C: malloc/calloc.
\end{itemize}

\subsection{Выделение памяти на кучу}

За счет чего реализованы библиотечные функции malloc и calloc?

Для этого используется один из системных вызовов:
\begin{itemize}
	\item \textbf{brk} --- устаревшая, но простая. Используется в glibc malloc до 128 Кб.
	\item \textbf{mmap} --- более гибкий инструмент.
\end{itemize}

\subsection{mmap}

Было на семах. 

Узнать больше: \textit{man mmap}

\subsection{Ограничения на память}

Ограничения можно посмотреть с помощью \textit{ulimit -a}.

\subsection{Что если память кончилась?}

Out-of-memory убийца процессов:
\begin{itemize}
	\item Найти жертву для убийства
	\item Очистить память
\end{itemize}

С каждый процессом связан некоторый рейтинг (/proc/[pid]/oom\_score), на основе которого
выбирается жертва.

Рейтинг вычисляется ядром. У процессов с высоким потреблением памяти рейтинг более
высокий, у привилегированных процесоов --- более маленький.

\subsection{Overcommit}

\begin{Def}
	\underline{Overcommit} --- это когда мы выделяем памяти больше, чем есть в системе.
	Это не вылетит пока мы не захотим ее использовать.
\end{Def}

Настроить стратегию при overcommit можно командой sysctl. 

Варианты стратегий:
\begin{itemize}
	\item OVERCOMMIT\_ALWAYS
	\item OVERCOMMIT\_GUESS --- стоит по умолчанию. Решение выносится на
	усмотрение ядра. Почти всегда это OVERCOMMIT\_ALWAYS.
	\item OVERCOMMIT\_NEVER
\end{itemize}